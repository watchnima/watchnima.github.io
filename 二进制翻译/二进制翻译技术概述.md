## 二进制翻译技术概述

[TOC]

#### 要做什么

解决两个不同结构的语义鸿沟,在一个架构运行另一个架构设计的软件

* 指令系统差异:寄存器,标志位,系统态,字节次序
* ABI差异:不同函数之间互相调用,参数如何传递,对其要求
* OS差异:系统调用和各种服务

#### 分类

* 静态(离线),动态
* 全系统(模拟一台机器),用户进程,函数/模块

#### 例子

* qemu

* LLBT
* 等等

#### 关键技术点

* 代码识别和控制流重建
  * 二进制文件中哪些是代码,哪些是数据(静态做很困难,...怎么找目标地址)
  * 把代码分成基本块,根据跳转信息建立控制流图(难点是建立控制流图)
* 各种层次的差异处理(工作量最大的地方)
* 翻译方法
  * 源-中间-目标
  * 源-目标
  * 是否容易扩展源和目标的扩展支持?
* 性能优化
  * 寄存器分配
  * 访存优化(最难)
  * 并行
  * 动态:识别热点,分层优化(啥时候启动最高级别复杂优化?)(我们有芯片团队,有硬件支持)
  * 静态:传统编译技术(难点:边缘情况,为了正确性需要保守一些,有硬件支持就可以激进一些)
* 硬件辅助
  * transmeta,龙芯...

#### 需要了解的基础知识

* 多个体系结构
  * 指令集(x86-64,arm-64,mips-64),ABI手册,OS
* 二进制文件
  * ELF/PCOFF等执行文件格式
* loader/linker
* compiler
* OS,系统调用
* 库函数
* 龙芯为二进制翻译做的支持

#### 内容提要

##### 初步分工

* qemu
  * 理解和消化课题组历史积累:张小春\刘奇\靳国杰等博士论文
  * 尝试恢复靳国杰的工作状态:qemu优化,运行linux/X86,对比coremark在龙芯native性能和qemu允许的linux/x86的性能
* rev.ng(意大利米兰大学的团队,静态翻译)
  * 开源代码http://rev.ng,源码在github,网站有文档和相关论文
  * 阅读论文
  * 尝试在龙芯上运行rev.ng
  * 静态翻译coremark linux/x86到龙芯,比较性能
* llbt(编译器框架,静态翻译,70%-100%性能)
  * 阅读其课题组论文系列相关文章,做综述报告